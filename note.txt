/ ******  printing decimal ******/ 
(1) Printing to 2 decimal places (C++)
double ret = sqrt(5);  
cout.setf(ios::fixed); 
cout.setf(ios::showpoint); 
cout.precision(2); 
cout << ret << endl;

/****** Printing date and time *******/ 
#include <ctime>
#include <iostream>
using namespace std;
int main() {
    time_t t = time(0);   // get time now
    struct tm * now = localtime( & t );
    cout << (now->tm_year + 1900) << '-' 
         << (now->tm_mon + 1) << '-'
         <<  now->tm_mday 
         << endl;
}

/******* Manacher's Algorithm *******/ 
// Transform S into T.
// For example, S = "abba", T = "^#a#b#b#a#$".
// ^ and $ signs are sentinels appended to each end to avoid bounds checking
string preProcess(string s) {
  int n = s.length();
  if (n == 0) return "^$";
  string ret = "^";
  for (int i = 0; i < n; i++)
    ret += "#" + s.substr(i, 1);
 
  ret += "#$";
  return ret;
}
 
string longestPalindrome(string s) {
  string T = preProcess(s);
  int n = T.length();
  int *P = new int[n];
  int C = 0, R = 0;
  for (int i = 1; i < n-1; i++) {
    int i_mirror = 2*C-i; // equals to i' = C - (i-C)
    
    P[i] = (R > i) ? min(R-i, P[i_mirror]) : 0;
    
    // Attempt to expand palindrome centered at i
    while (T[i + 1 + P[i]] == T[i - 1 - P[i]])
      P[i]++;
 
    // If palindrome centered at i expand past R,
    // adjust center based on expanded palindrome.
    if (i + P[i] > R) {
      C = i;
      R = i + P[i];
    }
  }
 
  // Find the maximum element in P.
  int maxLen = 0;
  int centerIndex = 0;
  for (int i = 1; i < n-1; i++) {
    if (P[i] > maxLen) {
      maxLen = P[i];
      centerIndex = i;
    }
  }
  delete[] P;
  
  return s.substr((centerIndex - 1 - maxLen)/2, maxLen);
}

/********** How many ones are there in the binary representation of n? *****/ 
int setbits(long long n){
	int count = 0;  
	while (n){
		n &= (n-1); 
		count++; 
	}
	return count;  
}  

/****** Brute force string search *******/ 
vector<int> naiveSearch(const string &H,const string &N){
	vector<int> ret; 
	for (int begin = 0; begin + N.size() <= H.size(); begin++){
		bool matched = true; 
		for (int i = 0; i < N.size(); i++){
			if (H[begin+i] != N[i]){
				matched = false; 
				break; 
			}
		}
		if (matched) ret.push_back(begin); 
	}
	return ret; 
}


/******** checking if given set of coordinates is clockwise or counter-clockwise ******/  
int main(){
	int t; 
	cin >> t; 
	while (t--){
		int n; 
		cin >> n; 
		vector< pair<int,int> > v; 
		for (int i = 0; i < n; i++){
			int x,y; 
			cin >> x >> y;  v.push_back(make_pair(x,y)); 
		}
		v.push_back(make_pair(v[0].first,v[0].second));  
		int ans1 = 0, ans2 = 0; 
		for (int i = 0; i < n; i++){
			ans1 += v[i].first*v[i+1].second;  
			ans2 += v[i].second*v[i+1].first;  
		}
		if (ans1-ans2 > 0) cout << "fight" << endl; // counter-clockwise 
		else cout << "run" << endl; 
	}
	return 0; 
}


/******* python binomial ********/  
def bino(n,m): 
	if m == 0 or m == n: 
		return 1 
	return bino(n-1,m-1)+bino(n-1,m) 

/******* printing running time *****/ 
#include <iostream.h>
#include <time.h>
using namespace std;
int main()
{
    clock_t t1,t2;
    t1=clock();
    //code goes here
    t2=clock();
    float diff ((float)t2-(float)t1);
    cout<< diff <<endl;
    // system ("pause");
    return 0;
}
/******** Calculating sum of digits from 1 to n *******/  
int digitSum(int n){
	if (n < 10) return n*(n+1)/2;  
	int d = log10(n);  
	int *a = new int[d+1]; 
	// computing sum of digits from 1 to 10^d-1 
	// d = 1, a[0] = 0; 
	// d = 2, a[1] = sum of digits from 1 to 9 = 45  
	// d = 3, a[2] = sum of digits from 1 to 99 = sum(9)*10+45*10
	// d = 4, a[3] = sum of digits from 1 to 999 = sum(99)*10 + 45*100
	a[0] = 0, a[1] = 45;  
	for (int i = 2; i <= d; i++){
		a[i] = a[i-1]*10 + 45*ceil(pow(10,i-1));  
	} 
	int p = ceil(pow(10,d));  
	int msd = n/p;  
	return msd*a[d]+(msd*(msd-1)/2)*p+msd*(1+n%p)+digitSum(n%p); 
}


/ ***** important algorithms *****/ 

(1) Euler Phi function 

void eulerPhi(int n){
	phi[1] = 1;  
	for (int i = 2; i <= n; i++){
		if (!phi[i]){
			for (int j = i; j <= n; j += i){
				if (!phi[j]){
					phi[j] = j;   
				}
				phi[j] = phi[j]/i*(i-1);  
			}
		}
	}
}

(2) Sieve of Erastosthenes 

void sieve(int n){
	isPrime[0] = isPrime[1] = 0;  
	for (int i = 2; i*i <= n; i++){
		if (isPrime[n]){
			for (int j = i*i; j <= n; j += i){
				isPrime[j] = 0;  
			}
		}
	}
}

(3) Dijkstra's Algorithm 

struct edge{int to,cost;}; 
typedef pair<int,int> P;  // 최단거리,노드번호  

int V; 
vector<edge> G[MAXV]; 
int d[MAXV]; 

void dijkstra(int s){
	priority_queue< P,vector<P>,greater<P> > que;  
	fill(d,d+V,INF); 
	d[s] = 0;  
	que.push(P(d[s],s));  
	while (!que.empty()){
		P p = que.top(); que.pop(); 
		int v = p.second;  
		if (d[v] < p.first) continue;  
		for (int i = 0; i < G[v].size(); i++){
			edge e = G[v][i];  
			if (d[e.to] > d[v]+e.cost){
				d[e.to] = d[v]+e.cost;  
				que.push(P(d[e.to],e.to));  
			}
		}
	}
}

Commonly used algorithms in programming competitions

- Mostly written in C/C++
- Not a complete program. They are just templates. 
- Should modify according to the context of the problem. 
- We may define INF typically as 987654321 (or any number within the INT range, but be wary of overflows!). 

/////////// Graph Theory and Shortest Path Problems ///////////

(1) Checking if Bipartite Graph: 

vector<int> G[MAXV];  
int color[MAXV];  
int V; // number of nodes 

bool dfs(int v, int c){
	color[v] = c; 
	for (int i = 0; i < G[v].size(); i++){                                                
		if (color[G[v][i]] == c) return false; 
		if (color[G[v][i]] == 0 && !dfs(G[v][i],-c)) return false; 
	}
	return true; 
}

void solve(){
	for (int i = 0; i < V; i++){
		if (color[i] == 0){
			if (!dfs(i,1)){
				printf("No\n");  // not a Bipartite Graph.  
			}
		}
	}
	printf("Yes\n");  // given graph is Bipartite. 
}

(2) Obtaining Topological Sort (BFS)

int graph[MAXN][MAXV];  
int indegree[MAXV]; 
int topologicalOrder[MAXV]; 
int V; 

int main(){
	// get input 
	for (int i = 1; i <= V; i++){
		for (int j = 1; j <= V; j++){
			if (graph[j][i]) indegree[i]++;  
		}
	}
	queue<int> q; 
	for (int i = 1; i <= V; i++){
		if (indegree[i] == 0) q.push(i);  
	}
	int counter = 0, v; 
	while (!q.empty()){
		v = q.front(); q.pop();  
		topologicalOrder[v] = ++counter; 
		for (int i = 1; i <= V; i++){
			if (graph[v][i] && --indegree[i] == 0) q.push(i);  
		}
	}
	if (counter != n) printf("0\n");  
	else{
		vector< pair<int,int> > a; 
		for (int i = 1; i <= V; i++){
			a.push_back(make_pair(topologicalOrder[i],i));  
		}
		sort(a.begin(),a.end());  
		for (int i = 0; i < a.size(); i++){
			printf("%d\n",a[i].second);  
		}
	}
} 

(3) Bellman-Ford Algorithm

struct edge {int from, to, cost;};  
edge es[MAXE];  
int d[MAXV];  
int V,E; // number of vertices, number of information about edges.  
void shortest_path(int s){ // s is the starting node. 
	for (int i = 0; i < V; i++) d[i] = INF;  
	while (true){
		bool update = false; 
		for (int i = 0; i < E; i++){
			edge e = es[i]; 
			if (d[e.from] != INF && d[e.to] > d[e.from]+e.cost){
				d[e.to] = d[e.from]+e.cost; 
				update = true; 
			}
		}
		if (!update) break; 
	}
}


(4) Detecting negative cycle in a graph using Bellman-Ford

struct edge{int from,to,cost;};  
int d[MAXV]; 
edge es[MAXE];  
int V,E; 

bool find_negative_loop(){
	memset(d,0,sizeof(d)); 
	for (int i = 0; i < V; i++){
		for (int j = 0; j < E; j++){
			edge e = es[j];  
			if (d[e.to] > d[e.from]+e.cost){
				d[e.to] = d[e.from]+e.cost; 
				if (i == V-1) return true; // if we have updates even for the |V|th iteration. 
			}
		}
	}
	return false;  
}

(5) Dijkstra's Algorithm (O(|V|^2) version)

int cost[MAXV][MAXV]; // cost of edge 
int d[MAXV]; // contains shortest distance from starting node. 
int used[MAXV]; // checking if the node has been visited before.  
int V,E;  

void dijkstra(int s){ // s is the starting node.  
	fill(d,d+V,sizeof(d)); 
	fill(used,0,sizeof(used)); 
	d[s] = 0; 
	while (true){
		int v = -1; 
		for (int u = 0; u < V; u++){
			if (!used[u] && (d[u] < d[v] || v == -1)) v = u; 
		}
		if (v == -1) break; 
		used[v] = 1; // mark as used
		for (int u = 0; u < V; u++){
			d[u] = min(d[u],d[v]+cost[v][u]);  
		}
	}
}

(6) Dijkstra's Algorithm (O(|E|log|V|) version, using priority_queue (heap))

struct edge {int to, cost;};  
vector<edge> G[MAXV];  
int d[MAXV]; // contains shortest distance from starting node.  
typedef pair<int,int> P; // first is shortest distance, second is node number.  
int V,E;  

void dijkstra(int s){ // s is the starting node.  
	fill(d,d+V,INF); 
	d[s] = 0;  
	priority_queue< P, vector<P>, greater<P> > que; 
	que.push(P(d[s],s));  
	while (!que.empty()){
		P p = que.top(); que.pop();  
		int v = p.second; 
		if (d[v] < p.first) continue;  // the min distance is already decided for node v, so we can skip.
		for (int i = 0; i < G[v].size(); i++){
			edge e = G[v][i];  
			if (d[e.to] > d[v]+e.cost){
				d[e.to] = d[v]+e.cost; 
				que.push(P(d[e.to],e.to));  
			}
		} 
	}
}

(7) Floyd-Warshall Algorithm (for all pairs shortest path problem. My personal favourite!)

// O(|V|^3) algorithm 

int d[MAXV][MAXV];  
int V; 

void init(){
	for (int i = 0; i < V; i++){
		for (int j = 0; j < V; j++){
			if (i == j) d[i][j] = 0; 
			else d[i][j] = INF;  
		}
	}
}

void floyd_warshall(){
	for (int k = 0; k < V; k++){
		for (int i = 0; i < V; i++){
			for (int j = 0; j < V; j++){
				d[i][j] = min(d[i][j],d[i][k]+d[k][j]);  
			}
		}
	}
}

(8) Path Reconstruction 

int prev[MAXV]; // filled with -1 

// implement some shortest path algorithm 
// and update prev[]

vector<int> getPath(int t){
	// obtaining path from starting node to node t. 
	vector<int> path; 
	for (; t != -1; t = prev[t]) path.push_back(t);  
	reverse(path.begin(),path.end()); 
	return path; 
}

// floyd reconstruction 
int V; // no of nodes 
int adj[MAXV][MAXV]; 
int via[MAXV][MAXV]; // via[u][v] = largest intermediate node from u to v 
void floyd(){
	for(int i = 0; i < V; i++) adj[i][i] = 0; 
	memset(via,-1,sizeof(via));  
	for (int k = 0; k < V; k++){
		for (int i = 0; i < V; i++){
			for (int j = 0; j < V; j++){
				if (adj[i][j] > adj[i][k]+adj[k][j]){
					via[i][j] = k; 
					adj[i][j] = adj[i][k]+adj[k][j];  
				}
			}
		}
	}
}
void reconstruct(int u,int v,vector<int> &path){
	if (via[u][v] == -1){
		path.push_back(u); 
		if (u != v) path.push_back(v); 
	}else{
		int w = via[u][v]; 
		reconstruct(u,w,path); 
		path.pop_back(); // because w is repeated in our path 
		reconstruct(w,v,path); 
	}
}

/////////// MST algorithms ///////////

(1) Prim's Algorithm (O(|V|^2) version)  

// Mathematical Proof of Prim's algorithm: http://math.wikia.com/wiki/Proof_of_Prim's_algorithm

int V;  
int cost[MAXV][MAXV];  
int mincost[MAXV];  
int used[MAXV];  

int Prim(){
	for (int i = 0; i < V; i++){
		mincost[i] = INF; 
		used[i] = 0;  
	}
	mincost[0] = 0; 
	int res = 0;  
	while (true){
		int v = -1;  
		for (int u = 0; u < V; u++){
			if (!used[u] && (v == -1 || mincost[u] < mincost[v])) v = u;  
		}
		if (v == -1) break; 
		used[v] = 1;  
		res += mincost[v];  
		for (int u = 0; u < V; u++){
			mincost[u] = min(mincost[u],cost[v][u]);  
		}
	}
	return res; 
}

(2) Kruskal's Algorithm (O(|E|log|V|))
 
 // source code for union-find included 
 struct edge{ int u, v, cost; };  
 edge es[MAXE]; 
 int V,E;  

 bool cmp(const edge &e1, const edge &e2){
 	return (e1.cost < e2.cost); 
 }

 int Kruskal(){
 	sort(es,es+E,cmp);  
 	init_union_find(V);  
 	int res = 0;  
 	for (int i = 0; i < E; i++){
 		edge e = es[i]; 
 		if (!same(e.u,e.v)){
 			unite(e.u,e.v); 
 			res += e.cost;  
 		}
 	}
 	return res;  
 }

/////////// Number Theory ///////////
(1) Euclid's algorithm for GCD

int gcd(int a, int b){
	if (b == 0) return a; 
	return gcd(b,a%b);
}

(2) Prime Factorization (O(sqrt(n)))

#include <cstdio> 
#include <algorithm> 
#include <map> 
using namespace std; 

map<int,int> prime_factor(int n){
	map<int,int> res; 
	for (int i = 2; i*i <= n; i++){
		while (n%i == 0){
			++res[i];  
			n /= i;  
		}
	}
	if (n != 1) res[n] = 1;  
	return res;  
}

int main(){
	int n; 
	scanf("%d",&n);  
	map<int,int> ans = prime_factor(n);  
	for (map<int,int>::iterator it = ans.begin(); it != ans.end(); it++){
		for (int i = 0; i < it->second; i++){
			printf("%d ",it->first);  
		}
	}
	printf("\n");  
	return 0; 
}

(3) Extended Euclidean Algorithm 

int extgcd(int a, int b, int &x, int &y){
	// find (x,y) such that ax + by = gcd(a,b);  
	int d = a; 
	if (b != 0){
		d = extgcd(b,a%b,y,x); 
		y -= (a/b)*x;  
	}else{
		x = 1;  
		y = 0;  
	}
	return d;  
}

(4) Simple Prime test (O(sqrt(n)))

bool isPrime(int n){
	for (int i = 2; i*i <= n; i++){
		if (n%i == 0) return false;  
	}
	return n != 1;  
}

(5) Finding all divisors of a number (O(sqrt(n)))

vector<int> divisor(int n){
	vector<int> res; 
	for (int i = 2; i*i <= n; i++){
		if (n%i == 0){
			res.push_back(i);  
			if (i != n/i) res.push_back(n/i);  
		}
	}
	return res;  
}

(6) Sieve of Eratosthenes (O(nloglogn))

int prime[MAXN];  
bool isPrime[MAXN+1];  

int sieve(int n){
	int p = 0;  
	for (int i = 0; i <= n; i++){
		isPrime[i] = true; 
	}
	isPrime[0] = isPrime[1] = false; 
	for (int i = 2; i*i <= n; i++){
		if (isPrime[i]){
			prime[p++] = i;  
			for (int j = 2*i; j <= n; j += i) isPrime[j] = false;  
		}
	}
	return p; 
}

(7) Interval Sieve (number of primes between a and b)
 
typedef long long ll;  

bool isPrime[MAXL]; 
bool isPrimeSmall[MAXSQRTB];  

void segment_sieve(ll a, ll b){
	for (int i = 0; (ll)i*i < b; i++) isPrimeSmall[i] = true;   
	for (int i = 0; i < b-a; i++) isPrime[i] = true;  
	for (int i = 2; (ll)i*i < b; i++){
		if(isPrimeSmall[i]){
			for (int j = i*2; (ll)j*j < b; j += i) isPrimeSmall[j] = false;  
			for (ll j = max(2LL,((a+i-1)/i))*i;  j < b; j += i) isPrime[j-a] = false;  
		}
	}
}

(8) Fast exponentiation (recursive version): O(logn)

int power(int a, int x){
	if (x == 0) return 1; 
	if (x == 1) return a; 
	return power(a,x/2)*power(a,x/2)*power(a,x%2);  
}

(9) Fast exponentiation (non-recursive version): O(logn)

typedef long long ll; 

ll fastexpo(ll a, ll x){
	ll res = 1; 
	while (x){
		if (x&1) res = res*a;  
		a = a*a;  
		x >>= 1;  
	}
	return res;  
}	

(10) modular fast exponentiation (non-recursive version)

ll fastexpo(ll a, ll x, ll mod){
	ll res = 1;  
	while (x){
		if (x&1) res = res*a%mod; 
		a = a*a%mod;  
		x >>= 1;  
	}
	return res; 
}

(11) modular fast exponentiation (recursive version)

ll mod_pow(ll a, ll x, ll mod){
	if (x == 0) return 1; 
	ll res = mod_pow(a*a%mod,x/2,mod);   
	if (x&1) res = res*x%mod; 
	return res; 
}

/////////// Geometry /////////// 

(1) The geometric vector class 

const double PI = 2.0*acos(0.0);  
struct vector2{
	double x,y;  
	explicit vector2(double x_ = 0, double y_ = 0) : x(x_),y(y_) {} 
	// comparing two vectors 
	bool operator == (const vector2 &rhs) const{
		return x == rhs.x && y == rhs.y;  
	}
	bool operator < (const vector2 &rhs) const{
		return x != rhs.x ? x < rhs.x : y < rhs.y;  
	}
	// adding and subtracting vectors
	vector2 operator + (const vector2 &rhs) const{
		return vector2(x+rhs.x,y+rhs.y);  
	}
	vector2 operator - (const vector2 &rhs) const{
		return vector2(x-rhs.x,y-rhs.y);  
	}
	// multiplying by real number 
	vector2 operator * (double rhs) const{
		return vector2(x*rhs,y*rhs); 
	}
	// returns the length of the vector 
	double norm() const {return sqrt(x*x + y*y);}
	vector2 normalize() const{
		return vector2(x/norm(),y/norm());  
	}
	double polar() const { return fmod(atan2(y,x)+2*PI,2*PI); } 
	double dot(const vector2 &rhs) const{
		return x*rhs.x + y*rhs.y;  
	}
	double cross(const vector2 &rhs) const{
		return x*rhs.y - rhs.x*y; 
	}
	vector2 project(const vector2 &rhs) const{
		vector2 r = rhs.normalize();  
		return r*r.dot(*this);  
	}
}; 

(2) given points a,b,p, how much closer is a to b than a to p? 
double howMuchCloser(vector2 p,vector2 a,vector2 b){
	return ((b-p).norm() - (a-p).norm()); 
}

(3) implementing ccw() 

// from the origin, if vector b is ccw of a, it returns positive value, else negative. 
// if a and b are in parallel, 0 is returned. 
double ccw(vector2 a,vector2 b){
	return a.cross(b);   
}

// using p as the standard not the origin. 
double ccw(vector2 p,vector2 a,vector2 b){
	return ccw(a-p,b-p);  
}

(4) Implementing intersection 
// we find the intersection x of a line containing (a,b) and (c,d).  
// if the two lines are parallel, we return false, else true. 
bool lineIntersection(vector2 a,vector2 b,vector2 c,vector2 d,vector2 &x){
	double det = (b-a).cross(d-c);  
	if (fabs(det) < EPSILON) return false; 
	x = a+(b-a)*((c-a).cross(d-c)/det);  
	return true;  
}

(5) 선분과 선분의 교차점을 계산하는 segmentIntersection() 구현 
bool parallelSegments(vector2 a,vector2 b,vector2 c, vector2 d,vector2 &p){
	if (b < a) swap(a,b); 
	if (d < c) swap(c,d);  
	// 한 직선 위에 없거나 두 선분이 겹치지 않는 경우를 우선 걸러낸다. 
	if (ccw(a,b,c) != 0 || b < c || d < a) return false; 
	// 두 선분은 확실히 겹친다. 교차점을 하나 찾자.  
	if (a < c) p = c;  
	else p = a;  
	return true;  
}

bool inBoundingRectangle(vector2 p,vector2 a,vector2 b){
	if (b < a) swap(a,b); 
	return p == a || p == b || (a < p && p < b);  
}

bool segmentIntersection(vector2 a,vector2 b,vector2 c,vector2 d,vector2 &p){
	if (!lineIntersection(a,b,c,d,p)) return parallelSegments(a,b,c,d,p);  
	return inBoundingRectangle(p,a,b) && inBoundingRectangle(p,c,d);  
}

(6) 두 선분의 교차 여부를 좀더 간단하게 확인하는 segmentIntersects() 함수 구현  
// 두 선분이 서로 접촉하는지 여부를 반환한다. 
bool segmentIntersects(vector2 a,vector2 b,vector2 c,vector2 d){
	double ab = ccw(a,b,c) * ccw(a,b,d); 
	double cd = ccw(c,d,a) * ccw(c,d,b);  
	// 두 선분이 한 직선 위에 있거나 끝점이 겹치는 경우 
	if (ab == 0 && cd == 0){
		if (b < a) swap(a,b);  
		if (d < c) swap(c,d); 
		return !(b < c || d < a); 
	}
	return ab <= 0 && cd <= 0;  
}

(7) 점과 선 사이의 거리를 계산하는 함수 pointToLine()의 구현 
// 점 p에서 (a,b)에 내린 수선의 발을 구한다. 
vector2 perpendicularFoot(vector2 p,vector2 a,vector2 b){
	return a+(p-a).project(b-a);  
}
// 점 p와 (a,b) 직선 사이의 거리를 구한다. 
double pointToLine(vector2 p,vector2 a,vector2 b){
	return (p - perpendicularFoot(p,a,b])).norm();  
}

(8) 다각형의 넓이를 구하는 area() function  
double area(const vector<vector2> &p){
	double ret = 0;  
	for (int i = 0; i < p.size(); i++){
		int j = (i+1)%p.size();  
		ret += p[i].x*p[j].y - p[j].x*p[i].y;  
	}
	return fabs(ret)/2.0;  
}

(9) 주어진 점이 단순 다각형 내부에 포함되어 있는지 확인하는 isInside() 함수의 구현  
// 점 q가 다각형 p 내부에 포함되어 있을 경우 참, 아닌 경우 거짓을 반환한다. 
// q가 다각형의 경계 위에 있는 경우의 반환 값은 정의되어 있지 않다. 
bool isInside(vector2 q,const vector<vector2> &p){
	int crosses = 0; 
	for (int i = 0; i < p.size(); i++){
		int j = (i+1)%p.size();  
		// (p[i],p[j]) 가 반직선을 세로로 가로지르는가? 
		if ((p[i].y > q.y) != (p[j].y > q.y)){
			// 가로지르는 x좌표를 계산한다.  
			double atX = (p[j].x-p[i].x)*(q.y-p[i].y)/(p[j].y-p[i].y) + p[i].x;  
			if (q.x < atX) ++crosses; 
		}
	}
	return (crosses%2 > 0); 
}

/////////// Bitmasking ///////////


/////////// Classic Dynamic Programming /////////// 

(1) Maximum Subarray Sum Problem 

#include <cstdio> 
#include <climits>
#include <algorithm> 
using namespace std; 

int a[100001]; 
int dp[100001];  

int main(){
	int n; 
	scanf("%d",&n); 
	for (int i = 0; i < n; i++){
		scanf("%d",&a[i]); 
	}
	int res = INT_MIN;  
	dp[0] = a[0];  
	res = max(res,dp[0]); 
	for (int i = 1; i < n; i++){
		dp[i] = max(a[i],dp[i-1]+a[i]);  
		res = max(res,dp[i]); 
	}
	printf("%d\n",res);  
	return 0; 
}

(2) Finding derangements  


int countDer(int n){
	int der[n+1]; 
	der[0] = 1; 
	der[1] = 0;  
	der[2] = 1;  
	for (int i = 3; i <= n; i++){
		der[i] = (i-1)*(der[i-1]+der[i-2]);  
	}
	return der[n];  
}

(3) Travelling Salesman Problem  

int n; 
int d[MAXN][MAXN];  

int dp[1<<MAXN][MAXN]; 

int rec(int S,int v){
	// set of visited vertices: S, current location v 
	if (dp[S][v] >= 0){
		return dp[S][v];  
	}
	if (S == (1<<n)-1 && v == 0){
		return dp[S][v] = 0;  // visited all vertices and coming back to original location 
	}
	int res = INF; 
	for (int u = 0; u < n; u++){
		if (!(S >> u&1)){
			// 다음에 u로 이동  
			res = min(res,rec(S|1<<u,u)+d[v][u]);  
		}
	}
	return dp[S][v];  
}

void solve(){
	memset(dp,-1,sizeof(dp)); 
	printf("%d\n",rec(0,0));  
}

(4) Travelling Salesman Problem (iterative method)

int dp[1<<MAXN][MAXN]; // DP table
 
void solve(){
	for (int S = 0; S < 1<<n; S++){
		fill(dp[S],dp[S]+n,INF); 
	}
	dp[(1<<n)-1][S] = 0; 
	for (int S = (1<<n)-2; S >= 0; S--){
		for (int v = 0; v < n; v++){
			for (int u = 0; u < n; u++){
				if (!(S>>u&1)){
					dp[S][v] = min(dp[S][v],dp[S|1<<u][u]+d[v][u]); 
				}
			}
		}
	}
	printf("%d\n",dp[0][0]);  
}

(5) O(nlogn) LIS problem 

int dp[MAXN]; 

void solve(){
	fill(dp,dp+n,INF); 
	for (int i = 0; i < n; i++){
		*lower_bound(dp,dp+n,a[i]) = a[i];  
	}
	printf("%d\n",lower_bound(dp,dp+n,INF)-dp); 
}

(6) O(n^2) LIS Problem
for (int j = 0; j < n; j++){
		dp[j] = 1;  
		for (int k = 0; k < j; k++){
			if (a[k] < a[j]){
				dp[j] = max(dp[j],1+dp[k]);  
			}
		}
		res = max(res,dp[j]);  
}

(6) coin change problem 

int min(int coins[],int m,int V){ // m: no of type of coins, V: value that has to be made  
	int table[V+1];  
	table[0] = 1;  
	for (int i = 1; i <= V; i++) table[i] = INT_MAX; 
	for (int i = 1; i <= V; i++){
		for (int j = 0; j < m; j++){
			if (coins[j] <= i){
				int temp = table[i-coins[j]];  
				if (temp != INT_MAX && temp < table[i]){
					table[i] = temp+1;  
				}
			}
		}
	}
	return table[V]; 
}


/////////// Union-Find Algorithm ///////////

(1) Implementation of union-find 

int par[MAXN];  // parent 
int rank[MAXN];  // depth of tree 

void init(int n){
	for (int i = 0; i < n; i++){
		par[i] = i; 
		rank[i] = 0;  
	}
}

int find(int x){
	if (par[x] == x) return x;  
	else{
		return par[x] = find(par[x]);  
	}
}

void unite(int x, int y){ // the union operation of sets x and y. 
	x = find(x); 
	y = find(y); 
	if (x == y) return;  
	if (rank[x] < rank[y]){
		par[x] = y;  
	}else{
		par[y] = x; 
		if (rank[x] == rank[y]) rank[x]++;  
	}
}

bool same(int x, int y){ // check if x and y are the same set. 
	 return find(x) == find(y);  
}

(2) Using union find to calculate the number of people in the set that contains u and v. 

#include <iostream> 
#include <vector> 
#include <cstdio> 
#include <cstring> 
#include <map> 
#include <algorithm> 
using namespace std;  

int parent[100005];  
int size[100005]; 
int rrank[100005];  
map<string,int> mp;  

void init(){
	for (int i = 0; i < 100005; i++){
		parent[i] = i; 
		size[i] = 1;   
		rrank[i] = 0; 
	}
}

int find(int x){
	if (x == parent[x]) return x; 
	return parent[x] = find(parent[x]); 
}

void merge(int u,int v){
	u = find(u), v = find(v); 
	if (u == v) return;  
	if (rrank[v] > rrank[u]) swap(u,v);  // 이제 rank[u] 가 rank[v]이상이다.  
	size[u] += size[v];  
	if (rrank[u] == rrank[v]) rrank[u]++; 
	parent[v] = u;  
	for (int i = 0; i < mp.size(); i++){
		if (parent[i] == v) parent[i] = u; 
 	}
}

int main(){
	ios_base::sync_with_stdio(false); cin.tie(NULL);  
	int t; 
	scanf("%d",&t); 
	while (t--){
		init(); 
		int F; 	
		scanf("%d",&F); 
		for (int i = 0; i < F; i++){
			char a[20],b[20];  
			scanf("%s %s",a,b);  
			int x,y; 
			if (!mp.count(a)) mp[a] = mp.size(); 
			x = mp[a]; 
			if (!mp.count(b)) mp[b] = mp.size();  
			y = mp[b];  
			merge(x,y); 
			printf("%d\n",size[find(x)]);  
 		}
	}
	return 0;  
}
 

/////////// Inchworm + Miscellaneous ///////////

(1) Subsequences 

int n,S; 
int a[MAXN]; 

void solve(){
	int s = 0, t = 0, sum = 0;  
	int res = n+1;  
	for (;;){
		while (t < n && sum < S){
			sum += a[t++];  
		}
		if (sum < S) break; 
		res = min(res,t-s);  
		sum -= a[s++]; 
	}
	if (res > n) printf("0\n"); // meaning there is no solution. 
	else printf("%d\n",res);  
}


(2) Flipping tiles to achieve an all white state from a mix of white and black states.   

int M,N; // M: number of rows, N: number of columns.    
int dy[5] = {-1,0,0,0,1}; 
int dx[5] = {0,-1,0,1,0};  

int tile[MAXM][MAXN]; // 0: white, 1: black
int opt[MAXM][MAXN]; 
int flip[MAXM][MAXN];  // performs the actual flipping process 

bool inRange(int y, int x){
	return (y >= 0 && y < M && x >= 0 && x < N);  
}

int get(int y, int x){
	int c = tile[y][x];  
	for (int i = 0; i < 5; i++){
		int ny = y+dy[i], nx = x+dx[i]	
		if (inRange(ny,nx)){
			c += flip[ny][nx];  
		}
	}
	return c%2;  
}

int calc(){
	// check starting from first row.  
	for (int i = 1; i < M; i++){
		for (int j = 0; j < N; j++){
			if (get(i-1,j) != 0){
				flip[i][j] = 1; 
			}
		}
	}
	// check if last row is all white  
	for (int j = 0; j < N; j++){
		if (get(M-1,j) != 0) return -1;  // this means there does not exist a solution.  
	}
	// if everything has been changed to white, check how many times in total we flipped.  
	int res = 0; 
	for (int i = 0; i < M; i++){
		for (int j = 0; j < N; j++){
			res += flip[i][j];  
		}
	}
	return res;  
}

void solve(){
	// in this step we decide what the first row will be 
	// note that there are 2^N ways we can decide what the first row will look like, 
	// beause each element in the row can be either clicked or not clicked, and there are 
	// total of N elements per row, so the number of cases is 2^N.  
	int res = -1;
	for (int i = 0; i < (1<<N); i++){
		memset(flip,0,sizeof(flip)); 
		for (int j = 0; j < N; j++){
			flip[0][N-j-1] = (i>>j&1);  
		}
		int num = calc();  
		if (num >= 0 && (res < 0 || res > num)){
			res = num; 
			memcpy(opt,flip,sizeof(flip));  
		}
	} 
	if (res < 0){
		printf("IMPOSSIBLE\n");  
	}else{
		for (int i = 0; i < M; i++){
			for (int j = 0; j < N; j++){
				printf("%d%c",opt[i][j],j == N-1 ? '\n' : ' ');  
			}
		}
	}
}

(3) Finding 4 values that sum to 0 

#include <algorithm> // for upper_bound, lower_bound. 

int A[MAXN],B[MAXN],C[MAXN],D[MAXN]; 
int CD[MAXN*MAXN+1];  
int n; 

void solve(){
	for (int i = 0; i < n; i++){
		for (int j = 0; j < n; j++){
			CD[i*n+j] = C[i]+D[j];  
		}
	}
	long long res = 0;  
	for (int i = 0; i < n; i++){
		for (int j = 0; j < n; j++){
			int cd = -(A[i]+B[j]);  
			res += upper_bound(CD,CD+n*n,cd)-lower_bound(CD,CD+n*n,cd);  
		}
	}
	printf("%lld\n",res);  
}


(4) nth term of fibonacci (for large n)

typdef vector<int> vec; 
typdef vector<vec> mat; 
typedef long long ll;  

const int M = 10000; 

mat mul(mat &A,mat &B){
	mat C(A.size(),vec(B[0].size()));  
	for (int i = 0; i < A.size(); i++){
		for (int j = 0; j < B.size(); j++){
			for (int k = 0; k < B[0].size(); k++){
				c[i][j] = (c[i][j]+A[i][k]*B[k][j])%M;  
			}
		}
	}
	return C;  
}

mat pow(math A, ll n){
	mat B(A.size(),vec(A.size())); 
	for (int i = 0; i < A.size(); i++){
		B[i][i] = 1;  
	}
	while (n > 0){
		if (n&1) mul(B,A);  
		A = mul(A,A); 
		n >>= 1; 
	}
	return  B; 
}

ll n; 
void solve(){
	mat A(2,vec(2));  
	A[0][0] = 1, A[0][1] = 1; 
	A[1][0] = 1, A[1][1] = 0; 
	A = pow(A,n);  
	printf("%d\n",A[1][0]);  
}

/////////// binary search ///////////

(1) Implementation 

int n,m,k[MAXN];  

bool binary_search(int x){
	int l = 0, r = n;  
	while (r-l >= 1){
		int mid = (l+r)/2;  
		if (k[mid] == x) return true; // found 
		else if (k[mid] < x) l = mid+1; 
		else r = mid; 
	}
	return false; 
}

(2) Cable Master (POJ 1064)

int N,K; 
double L[MAXN];  

#define INF 100100 // slightly larger than MAXL

bool chk(double x){
	int num = 0;  
	for (int i = 0; i < N; i++){
		num += (int)(L[i]/x);  
	}
	return num >= K;  
}

void solve(){
	int lb = 0, ub = INF; 
	while (ub-lb > 1e-5){
		double mid = (lb+ub)/2;  
		if (chk(mid)) lb = mid; 
		else ub = mid; 
	} 
	printf(".2f\n",floor(ub*100)/100); 
}


(3) 평균최대화 
int n,k; 
int w[MAXN],v[MAXN]; 
int y[MAXN]; 

bool C(double x){
	for (int i = 0; i < n; i++){
		y[i] = v[i]-x*w[i];  
	}
	sort(y,y+n);  
	int sum = 0; 
	for (int i = 0; i < n; i++){
		sum += y[n-i-1];  
	}
	return sum >= 0;  
}

void solve(){
	double lb = 0, ub = INF; // ub is slightly larger than max(x_i)
	while (ub-lb > 1){
		double mid = (lb+ub)/2; 
		if (C(mid)) lb = mid; 
		else ub = mid; 
	}
	printf("%.2f\n",ub);  
}

(4) USACO boj 10019 taking away some numbers apart from the first and last number 
to make the minimum possible average value. 

#include <iostream> 
#include <cstdlib> 
#include <algorithm> 
using namespace std; 

int n; 
int a[100001]; 
int psum[100001];  

bool ok(double avg){
	double maxi = avg*1-psum[1]; 
	for (int i = 2; i <= n-1; i++){
		if (psum[n]-avg*n+avg*i-psum[i]-maxi <= 0) return true;  
		maxi = max(maxi,avg*i-psum[i]);  
	}
	return false;  
}

int main(){
	ios_base::sync_with_stdio(false); 
	cin.tie(NULL);  	
	cin >> n; 
	for (int i = 1; i <= n; i++){
		cin >> a[i];  
	} 
	psum[1] = a[1];  
	for (int i = 2; i <= n; i++){
		psum[i] = a[i]+psum[i-1];  
	}
	double l = 0, r = 11111;  
	for (int it = 0; it < 100; it++){
		double mid = (l+r)/2.0;  
		if (ok(mid)) r = mid;  
		else l = mid; 
 	}
 	cout.setf(ios::fixed); 
 	cout.setf(ios::showpoint); 
 	cout.precision(3);  
 	cout << r << endl; 
 	return 0;  
}


/// Index Tree /// 

(1) getting input 
#include <cstdio> 
int IDT[1<<18],n,base;  
int main(){
	sacnf("%d",&n);  
	for (base = 1; base < n; base *= 2); 
	for (i = base; i < n+base; i++){
		scanf("%d\n",&IDT[i]);  
	}
}

(2) changing value 
#include <cstdio> 
int IDT[1<<18],n,base; 
void update(int a, int b){
	IDT[a] = b; 
	a >>= 1; 
	while (a){
		IDT[a] = IDT[2*a]+IDT[2*a+1];  
		a >>= 1;  
	}
}

(3) interval sum 
#include <cstdio> 
int IDT[1<<18],n,base;  
int lg_sum(int a,int b){
	int sum = 0; 
	while (a < b){
	 	if (a%2 == 1) sum += IDT[a], a++;  
	 	if (b%2 == 0) sum += IDT[b], b--; 
	 	a >>= 1, b >>= 1;  
	}
	if (a == b) sum += IDT[a];  
	return sum;  
} 

// toggling brackets //
#include <iostream> 
#include <cstdlib> 
#include <cstdio> 
#include <algorithm> 
#include <cstring> 
#include <string> 
using namespace std;  

int main(){
	cin >> s; 
	int depth = 0,ans = 0;  
	for (int i = 0; i < s.size(); i++){
		if (s[i] == '(') depth++; 
		else depth--;  
		if (depth < 0){
			ans++; 
			depth += 2;  
		}
	}
	ans += depth/2;  
	cout << ans << endl; 
	return 0; 
}

//////// sorting ////////// 

(1) Selection sort
void selectionSort(vector<int> &A){
	for (int i = 0; i < A.size(); i++){
		int minIndex = i;  
		for (int j = i+1; j < A.size(); j++){
			if (A[minIndex] > A[j]) minIndex = j;  
		}
		swap(A[i],A[minIndex]);  
	}
}

(2) Insertion Sort

void insertionSort(vector<int> &A){
	for (int i = 0; i < A.size(); i++){
		int j = i;  
		while (j > 0 && A[j-1] > A[j]){
			swap(A[j-1],A[j]);  
			--j;  
		}
	}
}


////////// KMP + Suffix Array ////////////// 


(1) Blog implementation 
#include <iostream> 
#include <string> 
#include <algorithm>
#include <cstdlib> 
#include <vector> 
using namespace std; 

vector<int> getPi(string p){
    int m = (int)p.size(), j=0;
    vector<int> pi(m, 0);
    for(int i = 1; i< m ; i++){
        while(j > 0 && p[i] !=  p[j])
            j = pi[j-1];
        if(p[i] == p[j])
            pi[i] = ++j;
    }
    return pi;
}

vector<int> kmp(string s, string p){
    vector<int> ans;
    vector<int> pi = getPi(p);
    int n = (int)s.size(), m = (int)p.size(), j =0;
    for(int i = 0 ; i < n ; i++){
        while(j>0 && s[i] != p[j])
            j = pi[j-1];
        if(s[i] == p[j]){
            if(j==m-1){
                ans.push_back(i-m+1);
                j = pi[j];
            }else{
                j++;
            }
        }
    }
    return ans;
}

int main(){
	string s,p; 
	cin >> s >> p;  
	vector<int> matched = kmp(s,p);  
	cout << (int)matched.size() << endl; 
	return 0; 
}

(2) JM Book Implementation 

vector<int> getPartialMatch(string &s){
	int m = s.size(); 
	vector<int> pi(m,0); 
	int begin = 1, matched = 0; 
	while (begin+matched < m){
		if (s[begin+matched] == s[matched]){
			++matched;  
			pi[begin+matched-1] = matched; 
		}else{
			if (matched == 0) ++begin; 
			else{
				begin += matched-pi[matched-1];  
				matched = pi[matched-1]; 
			}
		}
	}
	return pi;  
}

vector<int> kmp(string &H,string &N){
	int n = H.size(),m = N.size(); 
	vector<int> ret; 
	vector<int> pi = getPartialMatch(N); 
	int begin = 0, matched = 0; 
	while (begin <= n-m){
		if (matched < m && H[begin+matched] == N[matched]){
			++matched; 
			if (matched == m) ret.push_back(begin);  
		}else{
			if (matched == 0) ++begin; 
			else{
				begin += matched-pi[matched-1]; 
				matched = pi[matched-1]; 
			}
		}
	}
	return ret;
}

(3) Brute force string search 

vector<int> search(const string &H,const string &N){
	vector<int> ret; 
	for (int begin = 0; begin+N.size() <= H.size(); begin++){
		bool matched = true; 
		for (int i = 0; i < N.size(); i++){
			if (H[begin+i] != N[i]){
				matched = false; 
				break; 
			}
		}
		if (matched) ret.push_back(begin); 
	}
	return ret; // contains all the starting location of the substring of H that matches N. 
} 

(4) KMP implementation  
vector<int> kmp(const string &H,const string &N){
	vector<int> res;  
	vector<int> pi = getPartialTable(N);  
	int n = H.size(), m = N.size();    
	int begin = 0, matched = 0;  
	while (begin <= n-m){
		if (matched < m && H[begin+matched] == N[matched]){
			++matched;  
			if (matched == m) ret.push_back(begin);  
		}else{
			if (matched == 0) ++begin;  
			else{
				begin += matched-pi[matched-1];  
				matched = pi[matched-1];   
			}
		}
	}
	return ret; 
}

(5) KMP implementation again
vector<int> kmp(const string &H,const string &N){
	vector<int> ret;  
	vector<int> pi = getPartialTable(N);  
	int n = H.size(), m = N.size();  
	int begin = 0, matched = 0;  
	while (begin <= n-m){
		while (matched < m && H[begin+matched] == N[matched]){
			++matched; 
			if (matched == m) ret.push_back(begin);  
		}
		if (matched == 0) begin++;  
		else{ // 하나 이상 글자가 맞춰졌다. 
			begin += matched-pi[matched-1];  
			matched = pi[matched-1];  
		}	
	}
	return ret;  
}

(6) KMP again 

vector<int> kmp(string &H,string &N){
	vector<int> ret;  
	vector<int> pi = getPartialMatch(N); 
	int begin = 0, matched = 0;  
	int n = H.size(), m = N.size(); 
	while (begin <= n-m){
		while (matched < m && H[begin+matched] == N[matched]){
			++matched; 
			if (matched == m) ret.push_back(begin);  
		}
		if (matched == 0) ++begin; 
		else{
			begin += matched-pi[matched-1];  
			matched = pi[matched-1];  
		}
	}
	return ret;  
}

(7) partial match table 

vector<int> getPartialMatch(string &N){
	int m = N.size();  
	vector<int> pi(m,0); 
	int begin = 1, matched = 0; 
	while (begin+matched < m){
		if (N[begin+matched] == N[matched]){
			matched++; 
			pi[begin+matched-1] = matched;  
		}else{
			if (matched == 0) ++begin;  
			else{
				begin += matched-pi[matched-1];  
				matched = pi[matched-1];  
			}
		}
	}
	return pi;  
}

(8) maxoverlap 
int maxoverlap(string &a,string &b){
	int n = a.size(), m = b.size();  
	vector<int> pi = getPartialMatch(b);  
	int begin = 0, matched = 0;  
	while (begin < matched){
		if (matched < m && a[begin+matched] == b[matched]){
			++matched;  
			if (begin+matched == m) return matched;  
		}else{
			if (matched == 0) ++begin; 
			else{
				begin += matched-pi[matched-1];  
				matched = pi[matched-1];  
			}
		}
	}
}

(9) Suffix array to find the number of substrings of a string 
struct SuffixComparator
{
	const vector<int>& group;
	int t;
	SuffixComparator(const vector<int>& _group, int _t) : group(_group), t(_t) {}
	bool operator() (int a, int b)
	{
		if(group[a] != group[b])
			return group[a] < group[b];
		return group[a + t] < group[b + t];
	}
};

vector<int> getSuffixArray(const string& s)
{
	int n = s.size();

	int t = 1;
	vector<int> group(n+1);
	for(int i=0; i < n; i++)
		group[i] = s[i];
	group[n] = -1;

	vector<int> perm(n);
	for(int i=0; i < n; i++)
		perm[i] = i;

	while(t < n)
	{
		SuffixComparator compareUsing2T(group, t);
		sort(perm.begin(), perm.end(), compareUsing2T);

		t *= 2;
		if(t >= n)
			break;

		vector<int> newGroup(n+1);
		newGroup[n] = -1;
		newGroup[perm[0]] = 0;
		for(int i=1; i < n; i++)
			if(compareUsing2T(perm[i-1], perm[i]))
				newGroup[perm[i]] = newGroup[perm[i-1]] + 1;
			else
				newGroup[perm[i]] = newGroup[perm[i-1]];
		group = newGroup;
	}
	return perm;
}

int commonPrefix(const string& s, int i, int j)
{
	int k=0;
	while(i < s.size() && j < s.size() && s[i] == s[j])
		i++, j++, k++;
	return k;
}

int countSubstrings(const string& s)
{
	vector<int> a = getSuffixArray(s);
	int ret = 0;
	for(int i=0; i < a.size(); i++)
	{
		int cp = 0;
		if(i > 0)
			cp = commonPrefix(s, a[i-1], a[i]);
		ret += s.size() - a[i] - cp;
	}
	return ret;
}

int main(){
	string s; 
	cin >> s; 
	cout << countSubstrings(s) << endl;
	return 0; 
}

(10) 사전순으로 가장 앞에오는 원형 문자열 
string minShift(const string &s){
	string s2 = s+s;  
	vector<int> a = getSuffixArray(s2); 
	for (int i = 0; i < a.size(); i++){
		if (a[i] <= s.size()){
			return s2.substr(a[i],s.size());  
		}
	}
	return "ooops"; // should not reach this point. 
}




////////// 비대칭 타일랭 개수 ////////////// 
#include <iostream> 
#include <cstdlib> 
#include <cstdio> 
#include <algorithm> 
using namespace std; 
int dp[31];  
int n; 
int main(){
	scanf("%d",&n);  
	dp[0]=dp[1]=1;  
	for (int i=2;i<=n;i++){
		dp[i] = dp[i-1]+2*dp[i-2];  
	}
	int subtract = dp[n/2+!(n%2)]; 
	int ans = dp[n]-(dp[n]-subtract)/2;  
	printf("%d\n",ans);
	return 0; 
}


/////////// prefix sum for interval division ////////// 
#include <iostream> 
#include <cstdlib> 
#include <cstdio> 
#include <algorithm> 
using namespace std;  

int a[111111];  
int psum = 0; 

int main(){
	int N,M; 
	scanf("%d %d",&N,&M); 
	a[0] = 1;  
	for (int i = 1; i <= N; i++){
		int num; 
		scanf("%d",&num); 
		psum = (psum+num)%M; 
		a[psum]++;   
	}
	long long ans = 0;
	for (int i = 0; i < M; i++){
		ans += (long long)a[i]*(a[i]-1)/2; 
	}  
	printf("%lld\n",ans); 
	return 0; 
}


//////////// two pointer method /////////// 
(1) number of pairs (ai,aj) such that ai+aj = x
#include <iostream> 
#include <vector> 
#include <algorithm> 
#include <cstdio> 
using namespace std; 
 
vector<int> v; 
 
int main(){
    int n,num,x,cnt=0; 
    scanf("%d",&n);  
    for (int i = 0; i < n; i++){
        scanf("%d",&num); 
        v.push_back(num); 
    }    
    scanf("%d",&x); 
    sort(v.begin(),v.end()); 
    int i = 0, j = (int)v.size()-1;  
    while (i < j){
        if (v[i]+v[j] == x){ 
            ++cnt;  
            ++i; 
            --j; 
        }
        else if (v[i]+v[j] < x) ++i; 
        else if (v[i]+v[j] > x) --j;  
    }
    printf("%d\n",cnt); 
    return 0;  
}

(2) number of consecutive numbers that add to K 
int count(vector<int> &v,int K){
	int rangeSum = v[0], tail = 0, ret = 0;  
	for (int head = 0; head < v.size(); head++){
		while (rangeSum < K && tail+1 < v.size()){
			rangeSum += v[++tail];  
		}
		if (rangeSum == K) ret++;  
		rangeSum -= v[head];  
	}
	return ret;  
}


//////////// Network flow and bipartite matching /////////// 

(1) Code that solves bipartite matching

// A 와 B의 정점의 개수 
int n,m; 
// adj[i][j] = Ai 와 Bj가 연결되어 있는가? 
bool adj[MAX_N][MAX_M]; 
// 각 정점에 매칭된 상대 정점의 번호를 저장한다.  
vector<int> aMatch,bMatch;  
// dfs() 의 방문 여부 
vector<bool> visited; 
// A의 정점인 a에서 B의 매칭되지 않은 정점으로 가는 경로를 찾는다.  
bool dfs(int a){
	if (visited[a]) return false;  
	visited[a] = true; 
	for (int b = 0; b < m; b++){
		if (adj[a][b]){
			if (bMatch[b] == -1 || dfs(bMatch[b])){
				aMatch[a] = b;  
				bMatch[b] = a;  
				return true;  
			}
		}
	}
	return false;  
}  

// aMatch,bMatch 배열을 계산하고 최대 매칭의 크기를 반환한다. 
int bipartiteMatch(){
	// 처음에는 어떤 정점도 연결되어 있지 않다. 
	aMatch = vector<int>(n,-1); 
	bMatch = vector<int>(m,-1); 
	int size = 0; 
	for (int start = 0; start < n; start++){
		visited = vector<bool>(n,false);  
		if (dfs(start)) ++size; 
	}
	return size; 
}


/////////////////// Printing Power Set ////////////// 

void printPowerSet(char *set,int set_size){
	for (int i = 0; i < (1<<set_size); i++){
		for (int j = 0; j < set_size; j++){
			if (i & (1<<j)){
				printf("%c ",set[j]); 
			}
		}
		printf("\n");  
	}
	return;  
}


////// line sweep algorithm //////////////

(1) Problem: We divide the area into four regions, what is the maximum number of points 
that one of the four regions can contain?  

#include <iostream> 
#include <cstdio> 
#include <cstdlib>
#include <climits>  
#include <algorithm> 
#include <vector> 
#include <utility> 
using namespace std;  

#define x first 
#define y second

pair<int,int> a[1001];  
int n; 

int main(){
	cin >> n;  
	for (int i = 0; i < n; i++){
		cin >> a[i].x >> a[i].y; 
	}
	sort(a,a+n); 
	int ret = n;  
	for (int i = 0; i < n; i++){
		vector< pair<int,int> > below,above;  
		for (int j = 0; j < n; j++){
			if (a[j].y <= a[i].y) below.push_back(a[j]);  
			else above.push_back(a[j]);  
		}
		int belowIndex = 0, aboveIndex = 0;  
		while (belowIndex < below.size() || aboveIndex < above.size()){
			int xBorder = INT_MAX;  
			if (belowIndex < below.size()){
				xBorder = min(xBorder,below[belowIndex].x);  
			}
			if (aboveIndex < above.size()){
				xBorder = min(xBorder,above[aboveIndex].x); 
			}
			while (belowIndex < below.size() && below[belowIndex].x == xBorder){
				belowIndex++; 
			}
			while (aboveIndex < above.size() && above[aboveIndex].x == xBorder){
				aboveIndex++;  
			}
			ret = min(ret, max(max(belowIndex, (int)below.size() - belowIndex), max(aboveIndex, (int)above.size() - aboveIndex)));
		}
	}
	cout << ret << endl; 
	return 0;  
}

(2) Finding the shortest distance between each points 

#include <cstdio>
#include <vector>
#include <set>
#include <algorithm>
using namespace std;
struct Point {
    int x, y;
    Point() {
    }
    Point(int x, int y) : x(x), y(y) {
    }
    bool operator < (const Point &v) const {
        if (y == v.y) {
            return x < v.x;
        } else {
            return y < v.y;
        }
    }
};
bool cmp(const Point &u, const Point &v) {
    return u.x < v.x;
}
int dist(Point p1, Point p2) {
    return (p1.x-p2.x)*(p1.x-p2.x) + (p1.y-p2.y)*(p1.y-p2.y);
}
int main() {
    int n;
    scanf("%d",&n);
    vector<Point> a(n);
    for (int i=0; i<n; i++) {
        scanf("%d %d",&a[i].x,&a[i].y);
    }
    sort(a.begin(), a.end(), cmp);
    set<Point> candidate = {a[0], a[1]};
    int ans = dist(a[0], a[1]);
    int start = 0;
    for (int i=2; i<n; i++) {
        Point now = a[i];
        while (start < i) {
            auto p = a[start];
            int x = now.x - p.x;
            if (x*x > ans) {
                candidate.erase(p);
                start += 1;
            } else {
                break;
            }
        }
        int d = (int)sqrt((double)ans)+1;
        auto lower_point = Point(-100000, now.y-d);
        auto upper_point = Point(100000, now.y+d);
        auto lower = candidate.lower_bound(lower_point);
        auto upper = candidate.upper_bound(upper_point);
        for (auto it = lower; it != upper; it++) {
            int d = dist(now, *it);
            if (d < ans) {
                ans = d;
            }
        }
        candidate.insert(now);
    }
    printf("%d\n",ans);
    return 0;
}



////// CF switch or color problem /////////// 
#include <iostream> 
#include <cstdlib> 
#include <string> 
using namespace std;  

int main(){
	int n; 
	cin >> n;
	string str;
	cin >> str;
	int rr=0,bb=0;
	for(int i=0;i<n;i++){
		if(i%2==0){
			if(str[i]!='r')rr++;
		}else{
			if(str[i]!='b')bb++;
		}
	}
	int x=min(rr,bb),ans;
	ans=x+max(rr-x,bb-x);
	rr=0,bb=0;
	for(int i=0;i<n;i++){
		if(i%2==0){
			if(str[i]!='b')rr++;
		}else{
			if(str[i]!='r')bb++;
		}
	}
	x=min(rr,bb);
	ans=min(ans,x+max(rr-x,bb-x));
	cout << ans << endl;
	return 0;  
}

////// Modified Dijkstra Collection ////////

(1) Going from 1 to n visiting as many nodes as possible. 

#include <iostream> 
#include <cstdio> 
#include <cstdlib> 
#include <cstring> 
#include <vector> 
#include <queue> 
#include <algorithm> 
using namespace std; 

int val[5040][5040];  
int prv[5040][5040];  

int main(){
	int n,m,T; 
	cin >> n >> m >> T; 
	vector< vector< pair<int,int> > > G(n);  
	for (int i = 0; i < m; i++){
		int u,v,t;  
		cin >> u >> v >> t;  
		u--,v--;  
		G[u].push_back(make_pair(v,t));  
	}
	for (int i = 0; i < n; i++){
		for (int j = 0; j < n; j++){
			val[i][j] = prv[i][j] = -1; 
		}
	}
	val[0][0] = 0;  
	vector<int> res; 
	for (int iter = 1; iter < n; iter++){
		for (int i = 0; i < n; i++){
			if (val[iter-1][i] == -1) continue;  
			for (int j = 0; j < G[i].size(); j++){
				int vv = G[i][j].first; 
				int tt = G[i][j].second;  
				int nxt = val[iter-1][i]+tt;  
				if (nxt > T) continue;  
				if (val[iter][vv] == -1 || val[iter][vv] > nxt){
					val[iter][vv] = nxt;  
					prv[iter][vv] = i;  
				}
			}
		}
		if (val[iter][n-1] >= 0){
			res.clear();  
			int now = n-1;  
			int cur_iter = iter; 
			while (now != -1){
				res.push_back(now);  
				now = prv[cur_iter--][now];  
			}
			reverse(res.begin(),res.end());  
		}
	}
	cout << res.size() << endl; 
	for (int i = 0; i < res.size(); i++){
		cout << res[i]+1 << " "; 
	}
	cout << endl; 
	return 0; 
}


/////////// longest palindromic substring ///////// 
#include <iostream> 
#include <cstdlib> 
#include <cstdio> 
#include <cstring> 
#include <algorithm> 
using namespace std;  

void longestPalindromicSub(string str){
	int n = str.size();  
	bool dp[n][n];  
	memset(dp,0,sizeof(dp));  
	int maxlen = 1;  
	// dp[i][j] is false if str[i...j] is not a palindrome. 
	for (int i = 0; i < n; i++){
		dp[i][i] = true;  
	}
	// substring of length 2
	int start = 0;  
	for (int i = 0; i < n-1; i++){
		if (str[i] == str[i+1]){
			dp [i][i+1] = true;  
			start = i;  
			maxlen = 2;  
		}
	}
	for (int k = 3; k <= n; k++){
		for (int i = 0; i < n-k+1; i++){
			int j = i+k-1;  
			if (dp[i+1][j-1] && str[i]==str[j]){
				dp[i][j] = true;  
				if (k > maxlen){
					start = i;  
					maxlen = k;  
				}
			}
		}
	}
	for (int i = start; i <= start+maxlen-1; i++){
		cout << str[i];  
	}
}

int main(){
	int t; 
	cin >> t; 
	while (t--){
		string str; 
		cin >> str; 
		longestPalindromicSub(str); cout << endl; 
	}
	return 0;  
}


//////////// mergesort algorithm /////////////// 
#include <iostream> 
#include <cstdlib> 
#include <cstdio> 
#include <vector> 
using namespace std;  

#define INF 987654321

void merge(vector<int> &a,int p,int q,int r){
	int n1 = q-p+1;  
	int n2 = r-q; 
	int L[n1+1],R[n2+1];  
	for (int i = 0; i < n1; i++){
		L[i] = a[p+i];  
	}
	for (int j = 0; j < n2; j++){
		R[j] = a[q+1+j];  
	}
	L[n1] = R[n2] = INF;  
	int i = 0,j = 0;  
	for (int k = p; k <= r; k++){
		if (L[i] <= R[j]){
			a[k] = L[i]; 
			i++;  
		}else{
			a[k] = R[j]; 
			j++;  
		}
	}
	return; 
}	

void mergeSort(vector<int> &a,int p,int r){
	if (p < r){
		int q = (p+r)/2; 
		mergeSort(a,p,q);  
		mergeSort(a,q+1,r); 
		merge(a,p,q,r);  
	}
	return;  
}

int main(){
	vector<int> a; 
	a.push_back(12); a.push_back(5); a.push_back(23);  a.push_back(37);  a.push_back(43);  
	mergeSort(a,0,a.size()-1);
	for (int i = 0; i < a.size(); i++){
		cout << a[i] << " "; 
	} 
	cout << endl; 
	return 0;  
}
 
////// string token split by comma //////// 
string input;  
istringstream iss (input);  
string token;  
while (getline(iss,token,',')){
	cout << token << endl;  
}



////// useful binsearch ///////// 
#include <iostream> 
#include <cstdlib> 
#include <vector> 
using namespace std; 

int n; 

int binsearch(vector<int> &a,int key){
	int l = 0, h = n;  
	while (l < h){
		int m = (l+h+1)/2;  
		if (a[m] <= key) l = m;  
		else h = m-1;  
	}
	return a[l];  
}

int main(){
	ios_base::sync_with_stdio(false);  
	cin.tie(NULL);  
	cin >> n; 
	vector<int> a(n);  
	for (int i = 0; i < n; i++){
		cin >> a[i];   
	}
	int key; 
	cin >> key; 
	cout << binsearch(a,key) << endl;
	return 0;  
}


///// Reconstructing LIS ///// 
int n;  
int cache[101],S[100],choices[101]; 
int lis(int start){
	int &ret = cache[start+1]; 
	if (ret != -1) return ret;  
	ret = 1; 
	int bestNext = -1; 
	for (int next = start+1; next < n; next++){
		if (start == -1 || S[start] < S[next]){
			int cand = 1+lis(next); 
			if (ret < cand){
				ret = cand; 
				bestNext = next;  
			}
		}
	}
	chocies[start+1] = bestNext; 
	return ret; 
}

int reconstruct(vector<int> &list,int start){
	if (start != -1) list.push_back(S[start]); 
	int next = choices[start+1];  
	if (next != -1) reconstruct(list,next); 
}


/////// Counting the number of LIS ///////// 
int S[101], cache[101], cacheCnt[101]; 
int n; 
int lis(int start){
	int &ret = cache[start+1]; 
	if (ret != -1) return ret; 
	ret = 1; 
	for (int next = start+1; next < n; next++){
		if (start == -1 || S[start] < S[next]){
			ret = max(ret,1+lis(next));  
		}
	}
	return ret; 
}

const long long M; 

int count(int start){
	if (lis(start) == 1) return 1; 
	int &ret = cacheCnt[start+1]; 
	if (ret != -1) return ret; 
	ret = 0; 
	for (int next = start+1; next < n; next++){
		if ((start == -1 || S[start] < S[next]) && lis(start) == 1+lis(next)){
			ret = min(M,ret+count(next)); 
		}
	}
	return ret;  
}


///// Permutation Program /////////// 

// given k, calculate the kth lexicographic permutation 
// given the permutation determine its order. 
#include <iostream> 
#include <climits> 
#include <vector> 
#include <sstream> 
#include <algorithm> 
using namespace std; 

int n; 
long long factorial[21]; 

void calc(){
	factorial[0] = factorial[1] = 1;   
	for (int i = 2; i <= 20; i++){
		factorial[i] = factorial[i-1]*i;  
	}
}

string toString(int n){
	stringstream ss;  
	ss << n; 
	return ss.str(); 
}

string kth(int n,long long k){
	vector<int> v; 
	for (int i = 1; i <= n; i++){
		v.push_back(i);  
	}
	--k;  // we are going to skip k-1 permutations and print the kth. 
	string s;  
	long long fact = factorial[n];  
	for (int i = 0; i < n ;i++){
		fact = fact/(n-i);  
		int idx = k/fact; 
		s += toString(v[idx]);
		s += " ";   
		v.erase(v.begin()+idx); 
		k %= fact; 
	}
	return s; 
}

long long getIndex(vector<int> &X){
	long long ret = 0;  
	for (int i = 0; i < X.size(); i++){
		int less = 0; 
		for (int j = i+1; j < X.size(); j++){
			if (X[j] < X[i]){
				++less; 
			}
		}
		ret += factorial[X.size()-i-1]*less; 
	}
	return ret; 
}


int main(){
	ios_base::sync_with_stdio(false);  
	cin.tie(NULL); 
	calc(); 
	cin >> n; 
	int indicator; 
	cin >> indicator; 
	if (indicator == 1){
		long long k; 
		cin >> k; 
		string ans = kth(n,k);  
		ans.pop_back(); // get rid of the last " "; 
		cout << ans << endl;  
	}else{
		vector<int> X; 
		for (int i = 0; i < n; i++){
			int no; 
			cin >> no; 
			X.push_back(no); 
		}
		cout << getIndex(X)+1 << endl; 
	}
	return 0;  
}

///// summation problem ///// 
(1) Calculating the shortest consecutive sum of numbers that add up to N and have length at least L. 
#include <iostream> 
#include <cstdlib> 
#include <cmath> 
#include <algorithm> 
using namespace std; 

#define INF 987654321 

int N,L; 
int y = INF;  
int x; 

void f(int i){
	if (i&1){
		if (N/i*2 >= L && N/i <= 50 && i/2 + 1 >= N/i){
			if (N/i*2 < y){
				x = i/2-N/i+1; 
				y = N/i*2;  
			}
		}
		if (i >= L && i <= 100 && N/i >= i/2){
			if (i < y){
				x = N/i-i/2; 
				y = i;  
			}
		}
	}
}

int main(){
	ios_base::sync_with_stdio(false); 
	cin.tie(NULL); 
	cin >> N >> L;  
	for (int i = 1; i*i <= N; i++){
		if (N%i == 0){
			f(i); 
			f(N/i); 
		}
	}
	if (y != INF){
		for (int i = 0; i < y; i++){
			cout << x+i << " "; 
		}
		cout << endl;  
	}else{
		cout << -1 << endl; 
	}
	return 0; 
}

/////////// treap ///////////////
typedef int KeyType;  
struct Node{
	KeyType key; 
	int priority,size; 
	Node *left,*right;  
	Node (const KeyType &_key) : key(_key),priority(rand()),size(1),left(NULL),right(NULL){}
	void setLeft(Node *newLeft) { left = newLeft; calcSize(); }
	void setRight(Node *newRight) { right = newRight; calcSize(); }
	void calcSize(){
		size = 1; 
		if (left) size += left->size; 
		if (right) size += right->size;  
	}
};  

// adding node to treap and splitting 
typedef pair<Node*,Node*> NodePair; 
NodePair split(Node *root,KeyType key){
	if (root == NULL) return NodePair(NULL,NULL);  
	if (root->key < key){
		NodePair rs = split(root->right,key);  
		root->setRight(rs.first);  
		return NodePair(root,rs.second); 
	}
	NodePair ls = split(root->left,key); 
	root->setLeft(ls.second);  
	return NodePair(ls.first,root); 
}

// return the node of the treap 
Node *insert(Node *root,Node *node){
	if (root == NULL) return node;  
	if (root->priority < node->priority){
		NodePair splitted = split(root,node->key); 
		node->setLeft(splitted.first); 
		node->setRight(splitted.second);  
		return node;  
	}else if (node->key < root->key){
		root->setLeft(insert(root->left,node));  
	}else{ 
		root->setRight(insert(root->right,node));  
	}
	return node;  
}

// 트립의 루트를 가리키는 포인터 root가 있을 때 새 값 value를 다음과 같이 추가할 수 있습니다. 
// root = insert(root,new Node(value)); 

// a와 b가 두개의 트립이고, max(a) < min(b) 일때 이 둘을 합친다. 
Node *merge(Node *a,Node *b){
	if (a == NULL) return b; 
	if (b == NULL) return a; 
	if (a->priority < b->priority){
		b->setLeft(merge(a,b->left));  
		return b; 
	}
	a->setRight(merge(a->right,b)); 
	return a; 
}

// root를 루트로 하는 트립에서 key를 지우고 결과 트립의 루트를 반환한다.  
Node *erase(NOde *root,KeyType key){
	if (root == NULL) return root;  
	if (root->key == key){
		Node *ret = merge(root->left,root->right); 
		delete root;  
		return ret;  
	}
	if (key < root->key){
		root->setLeft(erase(root->left,key));  
	}else{
		root->setRight(erase(root->right,key)); 
	}
	return root;  
}

Node *kth(Node *root,int k){
	int leftSize = 0; 
	if (root->left != NULL) leftSize = root->left->size;  
	if (k <= leftSize) return kth(root->left,k);  
	if (k == leftSize+1) return root;  
	return kth(root->right,k-leftSize-1); 
}

int countLessThan(Node *root,KeyType key){
	if (root == NULL) return 0;  
	if (root->key >= key){
		return countLessThan(root->left,key);  
	}
	int ls = (root->left ? root->left->size : 0); 
	return ls+1+countLessThan(root->right,key);  
}


/////////// partial sum table trick /////////////
(1) How many contiguous intervals in the array sum up to x? 

int psum[MAXN],a[MAXN]; 
int n,x; 
map<int,int> mp; 

int main(){
	cin >> n >> x; 
	for (int i = 1; i <= n; i++){
		cin >> a[i];  
	} 
	for (int i = 1; i <= n; i++){
		psum[i] = psum[i-1]+a[i]; 
	}
	long long ans = 0;  
	mp[0]++;  
	for (int i = 1; i <= n; i++){
		mp[psum[i]]++; 
		if (mp.count(psum[i]-x)) ans += mp[psum[i]-x]; 
	}
	cout << ans << endl; 
	return 0; 
}


////////////// counting number of inversions ////////////
#include <iostream> 
#include <cstdlib> 
#include <vector>
#include <algorithm> 
using namespace std; 

long long countMoves(vector<int> &A,int left,int right){
	if (left == right) return 0;  
	int mid = (left+right)/2; 
	long long ret = countMoves(A,left,mid)+countMoves(A,mid+1,right); 
	vector<int> tmp(right-left+1); 
	int tempIndex = 0, leftIndex = left, rightIndex = mid+1;  
	while (leftIndex <= mid || rightIndex <= right){
		if (leftIndex <= mid && (rightIndex > right || A[leftIndex] <= A[rightIndex])){
			tmp[tempIndex++] = A[leftIndex++];  
		}else{
			// A[rightIndex] is smaller than all numbers remaining in the left half. 
			ret += mid-leftIndex+1;  
			tmp[tempIndex++] = A[rightIndex++];  
		}
	}
	for (int i = 0; i < tmp.size(); i++){
		A[left+i] = tmp[i];
	}
	return ret; 
}

int main(){
	ios_base::sync_with_stdio(false); 
	cin.tie(NULL);  
	int n;  
	cin >> n; 
	vector<int> a; 
	for (int i = 0; i < n; i++){
		int no; 
		cin >> no; 
		a.push_back(no); 
	}
	long long ans = countMoves(a,0,n-1);  
	cout << ans << endl; 
	return 0;  
}

/////// permutation recovery //////////////
problem: given a[], where a[i] contains the amount of numbers that appear before i in permutation P and are 
greater than i, recover P from a[i]. 
***use segment tree.  
#include <iostream> 
#include <cstdio> 
#include <cstdlib> 
#include <algorithm> 
#include <vector> 
using namespace std;  


const int MAXN = 1e5+1;  
int n,t[MAXN*4],a[MAXN];  

int kth(int h,int l,int r,int x){
	t[h]++;  
	if (l == r) return l; 
	int m = (l+r)/2; 
	if (x <= (m-l+1)-t[h*2+1]) return kth(h*2+1,l,m,x); 
	return kth(h*2+2,m+1,r,x+t[h*2+1]-(m-l+1)); 
}

int main(){
	//ios_base::sync_with_stdio(false); 
	//cin.tie(NULL); 
	int n; 
	//cin >> n; 
	scanf("%d",&n);  
	int x;  
	for (int i = 1; i <= n; i++){
		scanf("%d",&x);  
		a[kth(0,0,n-1,x+1)] = i;  
	}
	for (int i = 0; i < n; i++){
		printf("%d\n",a[i]); 
	}
	return 0; 
}


/////// Vertex Cut //////////////
vector< vector<int> > adj; 
vector<int> discovered;  // the order in which each vertex is found. Initialized to -1.  
vector<bool> isCutVertedx;  // stores whether if each vertex is a vertex cut or not.  
int counter = 0; 

// 역방향 간선으로 갈 수 있는 정점 중 가장 일찍 발견된 정점의 발견 시점. 
int findCutVertex(int here,bool isRoot){
	discovered[here] = counter++; 
	int ret = discovered[here]; 
	// if here is a root, then we check for the number of children subtrees. 
	int children = 0; 
	for (int i = 0; i < adj[here].size(); i++){
		int there = adj[here][i]; 
		if (discovered[there] == -1){
			++children; 
			// the highest number of node that we can reach from this subtree. 
			int subtree = findCutVertex(there,false); 
			if (!isRoot && subtree >= discovered[here]){ // subtree >= discovered[here] means the ancestor node connected to there is
				// below here. 
				isCutVertex[here] = true; 
			}
			ret = min(ret,subtree); 
		}else{
			ret = min(ret,discovered[there]);  
		}
	}
	if (isRoot) isCutVertex[here] = (children >= 2);  
	return ret;  
}


////////////// SCC //////////// 
// Tarjan's SCC algorithm 
vector< vector<int> > adj; 
// the component number starts from 0.  
vector<int> sccId; 
vector<int> discovered;  
stack<int> st;  
int sccCounter,vertexCounter;  

// here를 루트로 하는 서브트리에서 역방향 간선이나 교차 간선을 
// 통해 갈 수 있는 정점 중 최소 발견 순서를 반환한다. 
// (이미 강한 연결 컴포넌트로 묶인 정점으로 연결된 교차 간선은 무시한다). 
int scc(int here){
	int ret = discovered[here] = vertexCounter++; 
	// we put here in stack. Every child of here goes after here in the stack. 
	st.push(here); 
	for (int i = 0; i < adj[here].size(); i++){
		int there = adj[here][i];  
		if (discovered[there] == -1){
			ret = min(ret,scc(there)); 
		}
		else if (sccId[there] == -1){
			ret = min(ret,discovered[there]); 
		}
	}
	if (ret == discovered[here]){
		while (true){
			int t = st.top(); 
			st.pop();  
			sccId[t] = sccCounter; 
			if (t == here) break; 
		}
		sccCounter++;  
	}
	return ret;  
}

vector<int> tarjanSCC(){
	sccId = discovered = vector<int>(adj.size(),-1);  
	sccCounter = vertexCounter = 0;  
	for (int i = 0; i < adj.size(); i++){
		if (discovered[i] == -1) scc(i); 
	}
	return sccId; 
}

